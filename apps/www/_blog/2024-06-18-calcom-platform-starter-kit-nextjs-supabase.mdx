---
title: 'Cal.com launches Expert Marketplace built with Next.js and Supabase.'
description: Cal.com and Supabase team up to build an open-source platform starter kit for developers.
author:
image:
thumb:
categories:
  - developers
tags:
  - open-source
  - partnerships
  - nextjs
date: '2024-06-18'
toc_depth: 2
---

Contrary to popular belief, due to the biggest online beef in modern history, Cal.com and Supabase are actually supa good friends, united by a common mission to build open source software.

![ze germans tweet]()

So when the Cal.com team reached out about collaborating on on their new platform starter kit, we were excited to work together. Finally we could collaborate on a Product Hunt launch instead of competing against each other.

## What's the stack?

Initially the application was built to be run on SQLite. However, once requirements grew to include file storage, the Cal.com team remembered their Supabase frenemies and luckily, thanks to Prisma and Supabase, switching things over to Postgres three days before launch was a breeze.

## Prisma configuration for usage with Postgres on Supabase

When working with Prisma, your application will connect directly to your Postgres databases hosted on Supabase. To handle connection management efficiently, especially when working with serverless applications like Next.js, Supabase provides a connection pooler called [supavisor]() to make sure your database scales efficiently with your traffic.

The configuration is specified in the `schema.prisma` file where you provide the following connection strings:

```ts schema.prisma
datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
  schemas   = ["prisma"] // see multi-schema support below
}
```

This loads the relevant Supabase connections strings from your `.env` file

```bash .env
POSTGRES_PRISMA_URL="postgres://postgres.YOUR-PROJECT-REF:[YOUR-PASSWORD]@aws-0-[REGION].pooler.supabase.com:6543/postgres" # Transaction Mode
POSTGRES_URL_NON_POOLING="postgres://postgres.YOUR-PROJECT-REF:[YOUR-PASSWORD]@aws-0-[REGION].pooler.supabase.com:5432/postgres"  # Session Mode
```

You can find the values in the [Database settings](https://supabase.com/dashboard/project/_/settings/database) of your Supabase Dashboard.

For more details on using Prisma with Supabase, read the [officiale docs](https://supabase.com/partners/integrations/prisma).

### Multischema support in Prisma

In Supabase the `public` schema is exposed via the autogenerated [PostgREST]() API, which allows you to connect with your database from any environment that speaks HTTPS using the [Supabase client libraries]() like [supabase-js]() for example.

Since Prisma connects directly to your database, it's advisable to put your data on a separate schema that is not exposed via the API.

We can do this by enabling `multischema` support in the `schema.prisma` file:

```ts schema.prisma
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["multiSchema"]
}

model Account {
  id                String  @id @default(cuid())
  // ...

  @@schema("prisma")
}
```

## React Dropzone and Supabase Storage for profile image uploads

Supabase storage is an S3 compatible cloud-based object store that allows you to store files securely. It is conveniently integrated with [Supabase Auth]() allowing you to easily limit access for uploads and downloads.

Cal.com's Platforms Starter Kit runs their authentication on [Auth.js](https://authjs.dev/). Luckily though, Supabase Storage is supa felxible, allowing you to easily create signed upload URLs server-side to then upload assets from the client-side -- no matter which tech you choose to use for handling authentication for your app.

To facilitate this, we can create an API route in Next.js to generate these signed URLs:

```ts src/app/api/supabase/storage/route.ts
import { auth } from '@/auth'
import { env } from '@/env'
import { createClient } from '@supabase/supabase-js'

export const dynamic = 'force-dynamic' // defaults to auto
export async function GET(request: Request) {
  try {
    const session = await auth()
    if (!session) {
      return new Response('Unauthorized', { status: 401 })
    }
    const {
      user: { id },
    } = session
    // Generate signed upload url to use on client.
    const supabaseAdmin = createClient(env.NEXT_PUBLIC_SUPABASE_URL, env.SUPABASE_SERVICE_ROLE_KEY)
    await supabaseAdmin.storage.from('avatars').remove([id])
    const { data, error } = await supabaseAdmin.storage.from('avatars').createSignedUploadUrl(id)
    console.log(error)
    if (error) throw error

    return new Response(JSON.stringify(data), {
      status: 200,
    })
  } catch (e) {
    console.error(e)
    return new Response('Internal Server Error', { status: 500 })
  }
}
```

The `createSignedUploadUrl` method returns a `token` which we can then use on the client-side to upload the file selected by [React Dropzone]():

```tsx src/app/dashboard/settings/_components/supabase-react-dropzone.tsx
'use client'

import { env } from '@/env'
import { createClient } from '@supabase/supabase-js'
import Image from 'next/image'
import React, { useState } from 'react'
import { useDropzone } from 'react-dropzone'

export default function SupabaseReactDropzone({ userId }: { userId?: string } = {}) {
  const supabaseBrowserClient = createClient(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  )
  const { acceptedFiles, fileRejections, getRootProps, getInputProps } = useDropzone({
    maxFiles: 1,
    accept: {
      'image/jpeg': [],
      'image/png': [],
    },
    onDropAccepted: async (acceptedFiles) => {
      setAvatar(null)
      console.log(acceptedFiles)
      const { path, token }: { path: string; token: string } = await fetch(
        '/api/supabase/storage'
      ).then((res) => res.json())

      const { data, error } = await supabaseBrowserClient.storage
        .from('avatars')
        .uploadToSignedUrl(path, token, acceptedFiles[0])
    },
  })

  return (
    <div className="mx-auto mt-4 grid w-full gap-2">
      <div {...getRootProps({ className: 'dropzone' })}>
        <input {...getInputProps()} />
        <p>Drag 'n' drop some files here, or click to select files</p>
        <em>(Only *.jpeg and *.png images will be accepted)</em>
      </div>
    </div>
  )
}
```

## Custom Next.js Image loader for Supabase Storage

Supabase Storage also conveniently integrates with the Next.js Image paradigm, by creating a custom loader:

```ts src/lib/supabase-image-loader.ts
import { env } from '@/env'

export default function supabaseLoader({ src, width, quality }) {
  return `${env.NEXT_PUBLIC_SUPABASE_URL}/storage/v1/object/public/${src}?width=${width}&quality=${quality || 75}`
}
```

Now we just need to register the custom loader in the `next.config.js` file:

```js next.config.js
images: {
  loader: "custom",
  loaderFile: "./src/lib/supabase-image-loader.ts",
},
```

and we can start using the Next.js Image component by simply providing the file path within Supabase Storage:

```tsx
<Image
  alt="Expert image"
  className="aspect-square rounded-md object-cover"
  src="your-bucket-name/image.png"
  height="64"
  width="64"
/>
```

## Supabase Vercel Integration for one-click deploys

## Contributing to open source

## Resources

- [Cal.com Platform Starter Kit GitHub repository](https://github.com/calcom/platform-starter-kit)
