import Layout from '~/layouts/DefaultGuideLayout'
import {CodeBlock, Admonition, Accordion} from 'ui'
import Image from 'next/image'

export const meta = {
  id: 'auth-postgres-hooks',
  title: 'Auth Hooks (Postgres)',
  description: 'Use Supabase Postgres Functions to customize your authentication flow',
}

<Admonition type="info">
Hooks are in beta. They will be available for all projects in early 2024.
</Admonition>


Supabase allows you to use Postgres functions to alter the default Supabase Auth flow. Developers can use hooks to add custom behavior that's not supported natively.

Hooks help you:

- Track the origin of user signups by adding metadata
- Improve security by adding additional checks to password and multi-factor authentication
- Support legacy systems by integrating with identity credentials from external authentication systems
- Add additional custom claims to your JWT


You can use hooks at specific points along an Auth flow to perform custom behavior via Postgres Functions. These are known as **extensibility points**. The following extensibility points are available:

| Extensibility Point              | Available on Plan       |
|----------------------------------|-------------------------|
| Custom Access Token              | Free, Pro                |
| MFA Verification Attempt         | Teams and Enterprise    |
| Password Verification Attempt    | Teams and Enterprise    |

You can link a hook to an extensiblity point to signal to Supabase Auth that it should make use of the hook.


Below is a flow chart illustrating how Supabase Auth uses an Auth Hook:

<Image
  alt="Auth Hooks Flowchart"
  width={'1000'}
  height={'400'}
  src="/docs/img/guides/auth-postgres-hooks/hooks-flowchart.png"/>


## Create a Hook
### Write a Hook

A hook is a [Postgres Function](https://www.postgresql.org/docs/current/sql-createfunction.html) that takes in a `jsonb` object and return a `jsonb` object. In the body of a hook
you can transform the input payload via native [JSON operators](https://www.postgresql.org/docs/16/functions-json.html) or extensions such as [plv8](https://supabase.com/docs/guides/database/extensions/plv8) which allow you to transform data in other programming languages.

<Admonition type="warning">
The `?` JSONB operator is not supported as it conflicts with our ORM.
</Admonition>

Here is an example outline of what a hook looks like:

```sql
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
as $$
declare
  -- Insert variables here
begin
  -- Insert logic here
  return event;
end;
$$;
```

You can also view this template under `SQL Editor > Templates > Add Auth Hook (General)`

### Hook Errors

Return an error to change the behaviour of Supabase Auth. In the context of Supabase Auth, a hook is a runtime error which can change the behaviour of Supabase Auth. For instance, you can return an error to halt the authentication process for a user. Do not return developer errors which result from logical errors where the code does not do what the developer intended. For example, do not return divide by zero errors or errors which occur when inserting into a table.

An error is a JSON object with the following properties:

- `error` An object that contains information about the error.
    - `http_code` A number indicating the HTTP code to be returned. If not set, the code is HTTP 500 Internal Server Error.
    - `message` A message to be returned in the HTTP response. Required.

Here's an example:

```json
{
  "error": {
    "http_code": 429,
    "message": "You can only verify a factor once every 10 seconds."
  }
}
```

When an error is returned, Supabase Auth will ignore all other fields in the payload.

### Hook grants and roles

You need to assign additional permissions to the hook and the tables that it interacts with.

By default, Supabase Auth invokes hooks with the `supabase_auth_admin` role. This role doesn't have permissions to modify the `public` schema. You need to grant the role permission to execute your hook function:

```sql
grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;
```

Also revoke permissions from the `authenticated` and `anon` roles to ensure the function is not accessible by Supabase Serverless APIs.

```sql
revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon;
```

<Admonition type="caution">
Avoid adding a `security definer` tag to the function to avoid permission errors.
</Admonition>

Postgres functions have an implicit tag of `security invoker` which grants the calling user (`supabase_auth_admin`) appropriate permissions.

You can read more about `security definer` and `security invoker` tags [here](/docs/guides/database/functions#security-definer-vs-invoker).

### Timeouts

Ensure that your hooks complete within **2 seconds** to avoid any errors.

### Connect a Hook

In the dashboard, navigate to [`Authentication > Hooks (Beta)`](/dashboard/project/_/auth/hooks) and select the appropriate PostgreSQL function from the dropdown menu.


## MFA Verification Attempt Extensibility Point

You can add additional checks to the [Supabase MFA implementation](/docs/guides/auth/auth-mfa) with hooks. For example, you can:

- Limit the number of verification attempts performed over a period of time.
- Sign out users who have too many invalid verification attempts.
- Count, rate limit, or ban sign-ins.

**Inputs**

Supabase Auth will supply the following fields to your hook:

- `factor_id` Unique identifier for the MFA factor being verified. 
- `user_id` Unique identifier for the user.
- `valid` Whether the verification attempt was valid. For TOTP, this means that the six digit code was correct (true) or incorrect (false).

Example payload:

```json
{
	"factor_id": "6eab6a69-7766-48bf-95d8-bd8f606894db",
	"user_id": "3919cb6e-4215-4478-a960-6d3454326cec",
	"valid": true,
}
```

**Outputs**

Return this if your hook processed the input without errors.

- `decision` A string containing the decision on whether to allow authentication to move forward. Use `reject` to deny the verification attempt and log the user out of all active sessions. Use `continue` to use the default Supabase Auth behavior.
- `message` The message to show the user if the decision was `reject`.

Example output:

```json
{
   "decision": "reject",
   "message" : "You have exceeded maximum number of MFA attempts."
}
```
**Examples**

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
<TabPanel id="limit-failed-mfa-verification-attempts" label="Limit Failed MFA Verification Attempts">

Your company requires that a user can input an incorrect MFA Verification code no more than once every 2 seconds.

Create a table to record the last time a user had an incorrect MFA verification attempt for a factor.

```sql
create table public.mfa_failed_verification_attempts (
  user_id uuid not null,
  factor_id uuid not null,
  last_failed_at timestamp not null default now(),
  primary key (user_id, factor_id)
);
```

Create a hook to read and write information to this table. For example:

```sql
create function public.hook_mfa_verification_attempt(event jsonb)
  returns jsonb
  language plpgsql
as $$
  declare
    last_failed_at timestamp;
  begin
    if event->'valid' is true then
      -- code is valid, accept it
      return jsonb_build_object('decision', 'continue');
    end if;

    select last_failed_at into last_failed_at
      from public.mfa_failed_verification_attempts
      where
        user_id = event->'user_id'
          and
        factor_id = event->'factor_id';

    if last_failed_at is not null and now() - last_failed_at < interval '2 seconds' then
      -- last attempt was done too quickly
      return jsonb_build_object(
        'error', jsonb_build_object(
          'http_code', 429,
          'message',   'Please wait a moment before trying again.'
        )
      );
    end if;

    -- record this failed attempt
    insert into public.mfa_failed_verification_attempts
      (
        user_id,
        factor_id,
        last_refreshed_at
      )
      values
      (
        event->'user_id',
        event->'factor_id',
        now()
      )
      on conflict do update
        set last_refreshed_at = now();

    -- finally let Supabase Auth do the default behavior for a failed attempt
    return jsonb_build_object('decision', 'continue');
  end;
$$;

-- Assign appropriate permissions and revoke access
grant execute
  on function public.hook_mfa_verification_attempt
  to supabase_auth_admin;

grant all
  on table public.mfa_failed_verification_attempts
  to supabase_auth_admin;

revoke execute
  on function public.hook_mfa_verification_attempt
  from authenticated, anon;

revoke all
  on table public.mfa_failed_verification_attempts
  from authenticated, anon;
```
</TabPanel>
</Tabs>

## Password Verification Attempt Extensibility Point

Imagine that you wish to increase security beyond the requirements of the default password implementation in order to fulfill security or compliance requirements.

As this hook runs on unauthenticated requests, malicious users can abuse the hook by calling it multiple times.  Pay extra care when using the hook as you can unintentionally block legitimate users from accessing your application.

Check if a password is valid prior to taking any additional action to ensure the user is legitimate. Instead of blocking further verification attempts, consider sending an email or notification to an administrator via a trigger instead.

**Inputs**

- `user_id` Unique identifier for the user attempting to sign in. Correlate this to the `auth.users` table.
- `valid` Whether the password verification attempt was valid.

```json
{
	"user_id": "3919cb6e-4215-4478-a960-6d3454326cec",
	"valid": true,
}
```

**Outputs**

Return these only if your hook processed the input without errors.

- `decision` A string containing the decision whether to allow authentication to move forward. Use `reject` to completely reject the verification attempt and log the user out of all active sessions. Use `continue` to use the default Supabase Auth behavior.
- `message` The message to show the user if the decision was `reject`.
- `should_logout_user` Whether to logout a user if a `reject` decision is issued. Has no effect when a `continue` decision is issued.

Example output:

```json
{
   "decision": "reject",
   "message" : "You have exceeded maximum number of password Sign-In attempts.",
   "should_logout_user": "false"
}
```

**Examples**

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
<TabPanel id="limit-failed-password-verification-attempts" label="Limit Failed Password Verification Attempts">

As part of new security measures within the company, users can only input an incorrect password every 10 seconds and not more than that. You want to write a hook to enforce this.

Create a table to record each user's last incorrect password verification attempt.

```sql
create table public.password_failed_verification_attempts (
  user_id uuid not null,
  last_failed_at timestamp not null default now(),
  primary key (user_id)
);
```

Create a hook which to read and write information to this table. For example:

```sql
create function public.hook_password_verification_attempt(event jsonb)
returns jsonb
language plpgsql
as $$
  declare
    last_failed_at timestamp;
  begin
    if event->'valid' is true then
      -- password is valid, accept it
      return jsonb_build_object('decision', 'continue');
    end if;

    select last_failed_at into last_failed_at
      from public.password_failed_verification_attempts
      where
        user_id = event->'user_id';

    if last_failed_at is not null and now() - last_failed_at < interval '10 seconds' then
      -- last attempt was done too quickly
      return jsonb_build_object(
        'error', jsonb_build_object(
          'http_code', 429,
          'message',   'Please wait a moment before trying again.'
        )
      );
    end if;

    -- record this failed attempt
    insert into public.password_failed_verification_attempts
      (
        user_id,
        last_failed_at
      )
      values
      (
        event->'user_id',
        now()
      )
      on conflict do update
        set last_failed_at = now();

    -- finally let Supabase Auth do the default behavior for a failed attempt
    return jsonb_build_object('decision', 'continue');
  end;
$$;

-- Assign appropriate permissions
grant execute
  on function public.hook_password_verification_attempt
  to supabase_auth_admin;

grant all
  on table public.password_failed_verification_attempts
  to supabase_auth_admin;

revoke execute
  on function public.hook_password_verification_attempt
  from authenticated, anon;

revoke all
  on table public.password_failed_verification_attempts
  from authenticated, anon;
```
</TabPanel>
<TabPanel id="send-email-on-first-password-login" label="Send Email On First Password Login">

Your company wishes to send out a welcome email to users on the first time they login via email and password.

Create a table to track sign in attempts. We refrain from using the `auth.users` table's `last_signed_in_at` field as it includes successful OAuth and magic link sign ins.

```sql
create table public.password_sign_in_attempts (
  user_id uuid not null,
  attempt_id uuid not null,
  last_attempt_at timestamp not null default now(),
  attempt_successful boolean not null,
  primary key (user_id, attempt_id)
);
```

Store the API key of our email API provider in [Supabase Vault](/docs/guides/database/vault)
```sql
select vault.create_secret('my_secret', 'my_secret_name', 'my_secret_description');
```

Create a hook to send an email on first login with email and password:

```sql
create or replace function public.hook_send_welcome_email(event jsonb)
returns jsonb
language plpgsql
as $$
  declare
    user_id uuid;
    server_token text;
    email_address text;
    email_body text;
    response jsonb;
    http_code int;
    error_message text;
    attempt_count int;
  begin
    user_id := (event->>'user_id')::uuid;

    -- check if the password verification is valid
    if event->'valid' is true then
      -- Check the number of previous attempts
      select count(*) into attempt_count
      from public.password_sign_in_attempts
      where user_id = user_id;

      -- If it's the first successful login, send a welcome email
      if attempt_count = 0 then
        -- Fetch the server token and email address
        select token into server_token from vault.decrypted_secrets where name = 'your_postmark_key';
        select email into email_address from auth.users where id = user_id;

        -- Construct the welcome email body
        email_body := format('{"from": "yoursenderemail@example.com",
                               "to": "%s",
                               "subject": "Welcome to Our Service",
                               "textbody": "Welcome! Thank you for joining our service.",
                               "htmlbody": "<html><body><strong>Welcome!</strong> Thank you for joining our service.</body></html>",
                               "messagestream": "outbound"}', email_address);

        -- Perform the HTTP POST request using Postmark
        select net.http_post(
          'https://api.postmarkapp.com/email',
          email_body,
          'application/json',
          array['accept: application/json', 'x-postmark-server-token: ' || server_token]
        ) into response;

        -- Extract HTTP code and error message, if any
        http_code := (response ->> 'status')::int;
        error_message := response ->> 'message';

        -- Handle email sending errors
        if (response -> 'status' is null) or (http_code < 200 or http_code >= 300) then
          return jsonb_build_object(
            'error', jsonb_build_object(
              'http_code', coalesce(http_code, 0),
              'message', coalesce(error_message, 'error sending email')
            ));
        end if;
      end if;
    end if;

    -- Record the attempt, successful or not
    insert into public.password_sign_in_attempts (user_id, attempt_id, last_failed_at)
    values (user_id, (event->>'attempt_id')::uuid, now())
    on conflict (user_id, attempt_id)
    do update set last_failed_at = now();

    -- Continue with default behavior
    return jsonb_build_object('decision', 'continue');
  end;
$$;

-- Assign appropriate permissions
grant execute
  on function send_welcome_email
  to supabase_auth_admin;

revoke execute
  on function public.send_welcome_email
  from authenticated, anon;

grant all
  on table public.password_verification_attempts
  to supabase_auth_admin;

revoke all
  on table public.password_verification_attempts
  from authenticated, anon;
```
</TabPanel>
</Tabs>

## Custom Access Token Extensibility Point

The custom access token hook runs before a token is issued and allows you to add additional claims based on the authentication method used.

Claims returned must conform to our specification. Supabase Auth will check for these claims after the hook is run and return an error if they are not present.

These are the fields currently available on an access token:

| Field           | Required |
|-----------------|-------------------|
| `aud`           | Yes               |
| `exp`           | Yes               |
| `jti`           | No                |
| `iat`           | Yes               |
| `iss`           | No                |
| `nbf`           | No                |
| `sub`           | Yes               |
| `email`         | Yes               |
| `phone`         | Yes               |
| `app_metadata`  | No                |
| `user_metadata` | No                |
| `role`          | Yes               |
| `aal`           | Yes               |
| `amr`           | No                |
| `session_id`    | No                |


**Inputs**

- `user_id` Unique identifier for the user attempting to sign in. Correlate this to the `auth.users` table.
- `claims` Claims which are attached to the access token.
- `authentication_method` the authentication method used to request the access token. Possible values include:
`oauth`, `password`, `otp`, `totp`, `recovery`, `invite`, `sso/saml`, `magiclink`, `email/signup`, `email_change`, `token_refresh`.

**Outputs**

Return these only if your hook processed the input without errors.

- `claims` A json containing the updated claims after the hook has been run.

**Examples**

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
<TabPanel id="add-admin-role" label="Add Admin Role">

Your company would like to allow registered admin users to perform restricted actions by granting an `admin` claim to their token.

Create a profiles table with an `is_admin` flag:

```sql
create table profiles (
  user_id uuid not null primary key references auth.users (id),
  email text not null unique,
  is_admin boolean not null default false
);
```

Create a hook which adds an additional role based on the `is_admin` flag:

```sql
create or replace function public.custom_access_token_hook(event jsonb)
returns jsonb
language plpgsql
as $$
  declare
    claims jsonb;
    is_admin boolean;
  begin
    -- Check if the user is marked as admin in the profiles table
    select is_admin into is_admin from profiles where user_id = event->>'user_id';

    -- Proceed only if the user is an admin
    if is_admin then
      claims := event->'claims';

      -- Check if 'user_metadata' exists in claims
      if jsonb_typeof(claims->'user_metadata') is null then
        -- If 'user_metadata' does not exist, create an empty object
        claims := jsonb_set(claims, '{user_metadata}', '{}');
      end if;

      -- Set a claim of 'admin'
      claims := jsonb_set(claims, '{user_metadata, admin}', 'true');

      -- Update the 'claims' object in the original event
      event := jsonb_set(event, '{claims}', claims);
    end if;

    -- Return the modified or original event
    return event;
  end;
$$;

grant execute
  on function public.custom_access_token_hook
  to supabase_auth_admin;

revoke execute
  on function public.custom_access_token_hook
  from authenticated, anon;
```
</TabPanel>
<TabPanel id="add-metadata-claim-plv8" label="Add Claim Via PLV8">
Your company runs a new version of a gamification app and would like to add a `level` claim to the access token. We fetch the level of an existing user from the `profiles` table and assign new users a default level of zero.

Enable the `plv8` extension under [`Database > Extensions`](/dashboard/project/_/database/extensions)

```javascript
create or replace function custom_access_token_hook(event jsonb)
returns jsonb
language plv8
as $$
  var user_level;

  // Fetch the current user's level from the profiles table
  var result = plv8.execute("select level from profiles where user_id = $1", [event.user_id]);
  if (result.length > 0) {
    user_level = result[0].level;
  } else {
    // Assign a default level of 0 if no level is found
    user_level = 0;
  }

  // Check if 'claims' exists in the event object; if not, initialize it
  if (!event.claims) {
    event.claims = {};
  }

  // Update the level in the claims
  event.claims.level = user_level;

  return event;
$$;
```
</TabPanel>
<TabPanel id="restrict-access-to-select-users" label="Restrict Access To Select Users">
Your company has an internal application which should only be accessible to employees. All employees will have to log in via Single Sign On (SSO). We exempt some employees from the policy via an allowlist.

```sql
create or replace function public.restrict_application_access(event jsonb)
 returns jsonb
 language plpgsql
as $function$
declare
    authentication_method text;
    email_claim text;
    allowed_emails text[] := array['myemail@company.com', 'example@company.com'];
begin
    -- Extract email claim and authentication method
    email_claim = event->'claims'->>'email';
    authentication_method = event->'authentication_method';
    -- Authentication methods come double quoted (e.g. "otp")
    authentication_method = replace(authentication_method, '"', '');

    if email_claim ilike '%@supabase.io' or authentication_method = 'sso/saml' or email_claim = any(allowed_emails) then
        return event;
    end if;

    -- If none of the conditions are met, return an error
    return jsonb_build_object(
        'error', jsonb_build_object(
            'http_code', 403,
            'message', 'Staging access is only allowed to team members. Please use your @company.com account instead'
        )
    );
end;
$function$
;
-- manually added
grant execute
  on function public.restrict_application_access
  to supabase_auth_admin;

revoke execute
  on function public.restrict_application_access
  from authenticated, anon;
```
</TabPanel>
</Tabs>

export const Page = ({ children }) => <Layout meta={meta} children={children} />
export default Page
