---
id: 'auth-anonymous'
title: 'Anonymous Sign-Ins'
subtitle: 'Create and use anonymous users to authenticate with Supabase'
---

Enable Anonymous Sign-In to build apps which provide users an authenticated experience without requiring users to enter an email address, password, use an OAuth provider or provide any other PII (Personally Identifiable Information). Later, when ready, they can attach an authentication method to their account.

It's most useful for:

- E-commerce applications, such as shopping carts before check-out
- Full-feature demos without collecting personal information
- Temporary or throw-away accounts

<Admonition type="note" label="Anonymous user vs the anon key">

Calling `supabase.auth.signInAnonymously()` creates an anonymous user. It's just like a regular user, except the user can't access their account if they sign out, clear browsing data, or use another device.

Like regular users, the `authenticated` Postgres role will be used when using the Data APIs to access your project. JWTs for these users will have an `is_anonymous` claim which you can use to distinguish in RLS policies.

This is different from the `anon` API key which does not create a user and can be used to implement public access to your database as it uses the `anonymous` Postgres role.

</Admonition>

To get started, [enable anonymous sign-ins](/dashboard/project/_/auth/providers) for your Supabase Project.

<Admonition type="caution">

Review your existing RLS policies before enabling anonymous sign-ins. Anonymous users use the `authenticated` role. To distinguish between anonymous users and permanent users, your policies need to check the `is_anonymous` field of the user's JWT.

See the [Access control section](#access-control) for more details.

</Admonition>

<Admonition type="note" label="Self hosting and local development">

For self-hosting, you can update your project configuration using the files and environment variables provided. See the [self-hosting docs](/docs/guides/self-hosting#configuration) for more details.

</Admonition>

## Sign in anonymously

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
<TabPanel id="js" label="JavaScript">

Call the [`signInAnonymously()`](/docs/reference/javascript/auth-signinanonymously) method:

```js
const { data, error } = await supabase.auth.signInAnonymously()
```

</TabPanel>
</Tabs>

## Convert an anonymous user to a permanent user

Converting an anonymous user to a permanent user requires linking an identity to the user.

### Link an Email / Phone identity

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
<TabPanel id="js" label="JavaScript">

You can use the [`updateUser()`](/docs/reference/javascript/auth-updateuser) method to link an email or phone identity to the anonymous user.

```js
const { data, error } = await supabase.auth.updateUser({ email: 'example@email.com' })
```

</TabPanel>
</Tabs>

### Link an OAuth identity

<Tabs
  scrollable
  size="small"
  type="underlined"
  defaultActiveId="js"
  queryGroup="language"
>
<TabPanel id="js" label="JavaScript">

You can use the [`linkIdentity()`](/docs/reference/javascript/auth-linkidentity) method to link an oauth identity to the anonymous user.

```js
const { data, error } = await supabase.auth.linkIdentity({ provider: 'google' })
```

</TabPanel>
</Tabs>

## Access control

An anonymous user assumes the `authenticated` role just like a permanent user. You can use row-level security (RLS) policies to differentiate between an anonymous user and a permanent user by checking for the `is_anonymous` claim in the JWT returned by `auth.jwt()`:

```sql
create policy "Only permanent users can post to the news feed"
on news_feed for insert
to authenticated
with check ((auth.jwt()->>'is_anonymous')::boolean is false );

create policy "Anonymous and permanent users can view the news feed"
on news_feed for select
to authenticated
using ( true );
```

## Resolving identity conflicts

Depending on your application requirements, data conflicts can arise when an anonymous user is converted to a permanent user. For example, in the context of an e-commerce application, an anonymous user would be allowed to add items to the shopping cart without signing up / signing in. When they decide to sign-in to an existing account, you will need to decide how you want to resolve data conflicts in the shopping cart:

1. Overwrite the items in the cart with those in the existing account
2. Overwrite the items in the cart with those from the anonymous user
3. Merge the items in the cart together

## Abuse prevention and rate limits

Since anonymous users are stored in your database, bad actors can abuse the endpoint to increase your database size drastically. It is strongly recommended to [enable silent captcha or turnstile](/docs/guides/auth/auth-captcha) to prevent abuse for anonymous sign-ins. There is also an IP-based rate limit for anonymous sign-ins at 30 requests per hour which can be configured in your [dashboard](/dashboard/project/_/auth/rate-limits). You can refer to the full list of rate limits [here](/docs/guides/platform/going-into-prod#rate-limiting-resource-allocation--abuse-prevention).

## Automatic cleanup

We are working on adding the ability to automatically cleanup anonymous users that were created more than 30 days ago. For now, you can delete anonymous users from your project by running:

```sql
-- deletes anonymous users created more than 30 days ago
delete from auth.users
where is_anonymous is true and created_at < now() - interval '30 days';
```

## Resources

- [Supabase Account - Free Plan OK](https://supabase.com)
- [Supabase JS Client](https://github.com/supabase/supabase-js)
- [Supabase Flutter Client](https://github.com/supabase/supabase-flutter)
- [Supabase Kotlin Client](https://github.com/supabase-community/supabase-kt)
